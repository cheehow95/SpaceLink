<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SpaceLink WebRTC Client</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #4ade80;
            font-size: 1.5rem;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ef4444;
        }

        .status-dot.connected {
            background: #4ade80;
        }

        .status-dot.connecting {
            background: #f59e0b;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .stats {
            display: flex;
            gap: 15px;
            font-size: 12px;
            color: #888;
        }

        .stat {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .stat-value {
            color: #4ade80;
            font-weight: bold;
        }

        .video-container {
            position: relative;
            background: #000;
            border-radius: 12px;
            overflow: hidden;
            aspect-ratio: 16/9;
            margin-bottom: 15px;
        }

        #remoteVideo {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .quality-overlay {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 6px;
            font-size: 11px;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
        }

        @media (max-width: 900px) {
            .controls {
                grid-template-columns: 1fr;
            }
        }

        .control-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 15px;
        }

        .control-panel h3 {
            margin-bottom: 12px;
            color: #4ade80;
            font-size: 14px;
        }

        button {
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
            border: none;
            color: #000;
            padding: 10px 16px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, opacity 0.2s;
            font-size: 13px;
        }

        button:hover {
            transform: scale(1.02);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        button.disconnect {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: #fff;
        }

        button.secondary {
            background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
            color: #fff;
        }

        button.dark {
            background: rgba(255, 255, 255, 0.15);
            color: #fff;
        }

        .button-row {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .button-row button {
            flex: 1;
        }

        .ai-input-group {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        input[type="text"] {
            flex: 1;
            padding: 10px 12px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
            font-size: 13px;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #4ade80;
        }

        .connection-log {
            font-family: monospace;
            font-size: 11px;
            background: rgba(0, 0, 0, 0.3);
            padding: 8px;
            border-radius: 8px;
            max-height: 80px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .quick-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .quick-actions button {
            flex: 1;
            min-width: 70px;
            padding: 8px;
            font-size: 12px;
        }

        .keyboard-section {
            margin-top: 10px;
        }

        .key-row {
            display: flex;
            gap: 4px;
            margin-bottom: 4px;
        }

        .key-row button {
            min-width: 40px;
            padding: 8px 4px;
            font-size: 11px;
        }

        .key-row button.wide {
            min-width: 60px;
        }

        .key-row button.extra-wide {
            flex: 2;
        }

        .modifier-active {
            background: #f59e0b !important;
            color: black !important;
            border: 2px solid #fff;
        }

        .hotkey-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            margin-top: 10px;
        }

        .hotkey-grid button {
            padding: 8px;
            font-size: 11px;
        }

        select {
            padding: 8px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
            font-size: 12px;
            margin-right: 8px;
        }

        .settings-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .settings-row label {
            font-size: 12px;
            margin-right: 10px;
            min-width: 60px;
        }

        .toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }

        .toggle input[type="checkbox"] {
            width: 18px;
            height: 18px;
        }
    </style>
</head>

<body>
    <!-- Help Modal -->
    <div id="helpModal"
        style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.8); z-index:1000; align-items:center; justify-content:center;">
        <div style="background:#1e1e2e; padding:30px; border-radius:15px; max-width:500px; width:90%;">
            <h2 style="margin-bottom:15px; color:#4ade80;">‚å®Ô∏è Keyboard Shortcuts</h2>
            <table style="width:100%; font-size:14px;">
                <tr>
                    <td style="padding:5px;"><kbd>F11</kbd></td>
                    <td>Fullscreen</td>
                </tr>
                <tr>
                    <td style="padding:5px;"><kbd>Ctrl+P</kbd></td>
                    <td>Picture-in-Picture</td>
                </tr>
                <tr>
                    <td style="padding:5px;"><kbd>Ctrl+S</kbd></td>
                    <td>Screenshot</td>
                </tr>
                <tr>
                    <td style="padding:5px;"><kbd>Esc</kbd></td>
                    <td>Close modal</td>
                </tr>
            </table>
            <h3 style="margin:15px 0 10px; color:#4ade80;">üéÆ Gamepad</h3>
            <table style="width:100%; font-size:14px;">
                <tr>
                    <td style="padding:5px;">Left Stick</td>
                    <td>Move mouse</td>
                </tr>
                <tr>
                    <td style="padding:5px;">A/X</td>
                    <td>Left click / Enter</td>
                </tr>
                <tr>
                    <td style="padding:5px;">B/Y</td>
                    <td>Right click / Escape</td>
                </tr>
                <tr>
                    <td style="padding:5px;">Bumpers</td>
                    <td>Scroll up/down</td>
                </tr>
            </table>
            <button onclick="toggleHelp()"
                style="margin-top:20px; width:100%; padding:10px; background:#4ade80; color:#000; border:none; border-radius:8px; cursor:pointer;">Close</button>
        </div>
    </div>

    <div class="container">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
            <h1 style="margin:0;">üöÄ SpaceLink WebRTC</h1>
            <div style="display:flex; gap:10px;">
                <button onclick="toggleTheme()" title="Toggle Theme"
                    style="padding:8px 12px; font-size:16px;">üåì</button>
                <button onclick="toggleHelp()" title="Help" style="padding:8px 12px; font-size:16px;">‚ùì</button>
            </div>
        </div>

        <div class="status-bar">
            <div class="status-indicator">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">Disconnected</span>
            </div>
            <div class="stats">
                <div class="stat">üé¨ FPS: <span class="stat-value" id="fpsValue">--</span></div>
                <div class="stat">üì∂ <span class="stat-value" id="latencyValue">--</span></div>
                <div class="stat">üìä <span class="stat-value" id="bitrateValue">--</span></div>
                <div class="stat" id="signalStrength" style="opacity: 0.5">‚ñÇ‚ñÑ‚ñÜ‚ñà</div>
            </div>
        </div>

        <div class="video-container">
            <video id="remoteVideo" autoplay playsinline></video>
            <div class="quality-overlay" id="qualityOverlay">--</div>
            <div style="position: absolute; bottom: 10px; right: 10px; display: flex; gap: 8px;">
                <button onclick="takeScreenshot()" title="Screenshot"
                    style="padding: 8px 12px; font-size: 16px;">üì∏</button>
                <button onclick="togglePiP()" title="Picture-in-Picture"
                    style="padding: 8px 12px; font-size: 16px;">üñºÔ∏è</button>
                <button onclick="toggleFullscreen()" title="Fullscreen"
                    style="padding: 8px 12px; font-size: 16px;">‚õ∂</button>
            </div>
            <div id="latencyBadge"
                style="position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7); padding: 5px 10px; border-radius: 5px; font-size: 12px; display: none;">
                <span id="pingValue">--</span>ms
            </div>
        </div>

        <div class="controls">
            <!-- Connection Panel -->
            <div class="control-panel">
                <h3>üîó Connection</h3>
                <div class="button-row">
                    <button id="connectBtn" onclick="connect()">Connect</button>
                    <button id="disconnectBtn" class="disconnect" onclick="disconnect()" disabled>Disconnect</button>
                </div>
                <!-- Quality Controls -->
                <div class="settings-row" style="margin-top: 10px; margin-bottom: 10px;">
                    <label>Quality:</label>
                    <select id="resSelect" onchange="updateQuality()">
                        <option value="720">HD (720p)</option>
                        <option value="1080" selected>FHD (1080p)</option>
                        <option value="0">Native</option>
                    </select>
                    <select id="fpsSelect" onchange="updateQuality()">
                        <option value="15" selected>15 FPS</option>
                        <option value="30">30 FPS</option>
                        <option value="60">60 FPS</option>
                    </select>
                </div>
                <div class="toggle">
                    <input type="checkbox" id="autoReconnect" checked>
                    <label for="autoReconnect">Auto-reconnect</label>
                </div>
                <div class="connection-log" id="connectionLog"></div>
            </div>

            <!-- AI Commands Panel -->
            <div class="control-panel">
                <h3>ü§ñ AI Commands</h3>
                <div class="ai-input-group">
                    <input type="text" id="aiCommand" placeholder="e.g., 'type hello', 'press enter', 'copy'"
                        onkeypress="if(event.key==='Enter')sendAICommand()">
                    <button onclick="sendAICommand()" style="width: auto;">Send</button>
                </div>
                <div class="quick-actions">
                    <button onclick="sendCommand({type:'mouse_click', data:{button:'left'}})">Click</button>
                    <button onclick="sendCommand({type:'double_click', data:{button:'left'}})">DblClick</button>
                    <button onclick="sendCommand({type:'mouse_click', data:{button:'right'}})">RClick</button>
                    <button onclick="sendCommand({type:'scroll', data:{amount:200}})">‚Üë</button>
                    <button onclick="sendCommand({type:'scroll', data:{amount:-200}})">‚Üì</button>
                </div>
                <div class="hotkey-grid">
                    <button class="secondary" onclick="sendCommand({prompt:'copy'})">üìã Copy</button>
                    <button class="secondary" onclick="sendCommand({prompt:'paste'})">üìÑ Paste</button>
                    <button class="secondary" onclick="sendCommand({prompt:'undo'})">‚Ü©Ô∏è Undo</button>
                    <button class="secondary" onclick="sendCommand({prompt:'save'})">üíæ Save</button>
                    <button class="secondary" onclick="sendCommand({prompt:'select all'})">‚úì Sel All</button>
                    <button class="secondary" onclick="sendCommand({prompt:'find'})">üîç Find</button>
                </div>
            </div>

            <!-- Keyboard Panel -->
            <div class="control-panel">
                <h3>‚å®Ô∏è Keyboard</h3>
                <div class="keyboard-section">
                    <!-- Modifiers -->
                    <div class="key-row">
                        <button class="dark" id="btnShift" onclick="toggleModifier('shift')">Shift</button>
                        <button class="dark" id="btnCtrl" onclick="toggleModifier('ctrl')">Ctrl</button>
                        <button class="dark" id="btnAlt" onclick="toggleModifier('alt')">Alt</button>
                        <button class="dark" id="btnWin" onclick="toggleModifier('win')">Win</button>
                    </div>
                    <div class="key-row">
                        <button class="dark" onclick="sendKey('esc')">Esc</button>
                        <button class="dark" onclick="sendKey('f1')">F1</button>
                        <button class="dark" onclick="sendKey('f2')">F2</button>
                        <button class="dark" onclick="sendKey('f3')">F3</button>
                        <button class="dark" onclick="sendKey('f4')">F4</button>
                        <button class="dark" onclick="sendKey('f5')">F5</button>
                    </div>
                    <div class="key-row">
                        <button class="dark" onclick="sendKey('tab')">Tab</button>
                        <button class="dark wide" onclick="sendKey('backspace')">‚å´</button>
                        <button class="dark wide" onclick="sendKey('delete')">Del</button>
                        <button class="dark wide" onclick="sendKey('enter')">Enter</button>
                    </div>
                    <div class="key-row">
                        <button class="dark" onclick="sendKey('home')">Home</button>
                        <button class="dark" onclick="sendKey('end')">End</button>
                        <button class="dark" onclick="sendKey('pageup')">PgUp</button>
                        <button class="dark" onclick="sendKey('pagedown')">PgDn</button>
                    </div>
                    <div class="key-row">
                        <button class="dark" onclick="sendKey('up')">‚Üë</button>
                        <button class="dark" onclick="sendKey('down')">‚Üì</button>
                        <button class="dark" onclick="sendKey('left')">‚Üê</button>
                        <button class="dark" onclick="sendKey('right')">‚Üí</button>
                        <button class="dark extra-wide" onclick="sendKey('space')">Space</button>
                    </div>
                </div>
                <div class="hotkey-grid">
                    <button class="dark" onclick="sendHotkey(['alt','tab'])">Alt+Tab</button>
                    <button class="dark" onclick="sendHotkey(['win','d'])">Desktop</button>
                    <button class="dark" onclick="sendHotkey(['ctrl','shift','esc'])">TaskMgr</button>
                    <button class="dark" onclick="sendHotkey(['win','shift','s'])">üì∏ Snap</button>
                    <button class="dark" onclick="sendHotkey(['ctrl','t'])">New Tab</button>
                    <button class="dark" onclick="sendHotkey(['ctrl','w'])">Close Tab</button>
                </div>
            </div>
        </div>

        <!-- Second Row: Advanced Features -->
        <div class="controls" style="margin-top: 15px;">
            <!-- Audio & Monitor Panel -->
            <div class="control-panel">
                <h3>üñ•Ô∏è Display & Audio</h3>
                <div class="settings-row">
                    <label>Monitor:</label>
                    <select id="monitorSelect" onchange="selectMonitor()">
                        <option value="1">Loading...</option>
                    </select>
                </div>
                <div class="settings-row">
                    <label>Audio:</label>
                    <button id="audioToggle" class="dark" onclick="toggleAudio()">üîä On</button>
                    <input type="range" id="volumeSlider" min="0" max="100" value="100" style="flex:1; margin-left:8px;"
                        onchange="setVolume()">
                </div>
                <div class="button-row" style="margin-top:10px;">
                    <button class="secondary" onclick="loadMonitors()">üîÑ Refresh</button>
                </div>
            </div>

            <!-- File & Clipboard Panel -->
            <div class="control-panel">
                <h3>üìÅ Files & Clipboard</h3>
                <div class="button-row">
                    <button class="secondary" onclick="syncClipboardFrom()">üìã Get PC Clipboard</button>
                    <button class="secondary" onclick="syncClipboardTo()">üì• Send Clipboard</button>
                </div>
                <div class="settings-row" style="margin-top:8px;">
                    <label>Path:</label>
                    <input type="text" id="filePath" placeholder="C:\Users\..." style="flex:1;">
                </div>
                <div class="button-row">
                    <button class="dark" onclick="browseFiles()">üìÇ Browse</button>
                    <button class="dark" onclick="downloadFile()">‚¨áÔ∏è Download</button>
                </div>
                <div id="fileList" style="font-size:11px; max-height:60px; overflow-y:auto; margin-top:5px;"></div>
            </div>

            <!-- Recording & WoL Panel -->
            <div class="control-panel">
                <h3>üé¨ Recording & WoL</h3>
                <div class="button-row">
                    <button id="recordBtn" class="secondary" onclick="toggleRecording()">‚è∫Ô∏è Start</button>
                    <button class="dark" onclick="pauseRecording()">‚è∏Ô∏è Pause</button>
                    <button class="dark" onclick="listRecordings()">üìã List</button>
                </div>
                <div id="recordingStatus" style="font-size:11px; color:#4ade80; margin-top:5px;">Ready</div>
                <div style="margin-top:10px; border-top:1px solid rgba(255,255,255,0.1); padding-top:10px;">
                    <div class="settings-row">
                        <label>MAC:</label>
                        <input type="text" id="wolMac" placeholder="AA:BB:CC:DD:EE:FF" style="flex:1;">
                    </div>
                    <button class="dark" style="width:100%; margin-top:5px;" onclick="sendWakeOnLan()">‚ö° Wake
                        PC</button>
                </div>
            </div>
        </div>

        <!-- Third Row: Power & Quick Actions -->
        <div class="controls" style="margin-top: 15px;">
            <!-- Power Control Panel -->
            <div class="control-panel">
                <h3>‚ö° Power Control</h3>
                <div class="button-row">
                    <button class="dark" onclick="powerAction('lock')" title="Lock Screen">üîí Lock</button>
                    <button class="dark" onclick="powerAction('sleep')" title="Sleep">üò¥ Sleep</button>
                </div>
                <div class="button-row" style="margin-top:8px;">
                    <button class="disconnect" onclick="confirmPower('restart')" title="Restart">üîÑ Restart</button>
                    <button class="disconnect" onclick="confirmPower('shutdown')" title="Shutdown">‚èª Shutdown</button>
                </div>
            </div>

            <!-- Quick Launch Panel -->
            <div class="control-panel">
                <h3>üöÄ Quick Launch</h3>
                <div class="hotkey-grid">
                    <button class="dark" onclick="launchApp('explorer')">üìÅ Explorer</button>
                    <button class="dark" onclick="launchApp('notepad')">üìù Notepad</button>
                    <button class="dark" onclick="launchApp('cmd')">üíª CMD</button>
                    <button class="dark" onclick="launchApp('taskmgr')">üìä TaskMgr</button>
                    <button class="dark" onclick="launchApp('chrome')">üåê Chrome</button>
                    <button class="dark" onclick="launchApp('calc')">üî¢ Calc</button>
                </div>
            </div>

            <!-- Favorites Panel -->
            <div class="control-panel">
                <h3>‚≠ê Favorites</h3>
                <div id="favoritesList" style="display:flex; flex-wrap:wrap; gap:5px;">
                    <button class="secondary" onclick="addFavorite()">+ Add</button>
                </div>
            </div>
        </div>

        <!-- Fourth Row: System Stats -->
        <div class="controls" style="margin-top: 15px;">
            <!-- System Stats Panel -->
            <div class="control-panel" style="flex: 2;">
                <h3>üìä System Stats <button class="dark" onclick="refreshStats()"
                        style="padding:2px 8px; font-size:12px;">üîÑ</button></h3>
                <div style="display:grid; grid-template-columns: repeat(4, 1fr); gap:10px; text-align:center;">
                    <div>
                        <div style="font-size:24px;">üíª</div>
                        <div style="font-size:11px; color:#888;">CPU</div>
                        <div id="cpuValue" style="font-size:18px; font-weight:bold; color:#4ade80;">--%</div>
                    </div>
                    <div>
                        <div style="font-size:24px;">üß†</div>
                        <div style="font-size:11px; color:#888;">RAM</div>
                        <div id="ramValue" style="font-size:18px; font-weight:bold; color:#60a5fa;">--%</div>
                    </div>
                    <div>
                        <div style="font-size:24px;">üíæ</div>
                        <div style="font-size:11px; color:#888;">Disk</div>
                        <div id="diskValue" style="font-size:18px; font-weight:bold; color:#f472b6;">--%</div>
                    </div>
                    <div>
                        <div style="font-size:24px;">üîã</div>
                        <div style="font-size:11px; color:#888;">Battery</div>
                        <div id="batteryValue" style="font-size:18px; font-weight:bold; color:#fbbf24;">--%</div>
                    </div>
                </div>
            </div>

            <!-- Processes Panel -->
            <div class="control-panel">
                <h3>‚öôÔ∏è Top Processes</h3>
                <div id="processList" style="font-size:11px; max-height:80px; overflow-y:auto;">
                    Loading...
                </div>
            </div>
        </div>

        <!-- Fifth Row: Macros & Clipboard History -->
        <div class="controls" style="margin-top: 15px;">
            <!-- Macro Recording Panel -->
            <div class="control-panel">
                <h3>üé¨ Macro Recording</h3>
                <div class="button-row">
                    <button id="macroRecordBtn" class="secondary" onclick="toggleMacroRecording()">‚è∫Ô∏è Record</button>
                    <button class="dark" onclick="listMacros()">üìã List</button>
                </div>
                <div id="macroStatus" style="font-size:11px; color:#888; margin-top:5px;">Ready</div>
                <div id="macroList" style="font-size:11px; max-height:60px; overflow-y:auto; margin-top:5px;"></div>
            </div>

            <!-- Clipboard History Panel -->
            <div class="control-panel">
                <h3>üìã Clipboard History</h3>
                <button class="dark" onclick="refreshClipboardHistory()" style="width:100%; margin-bottom:5px;">üîÑ
                    Refresh</button>
                <div id="clipboardHistory" style="font-size:11px; max-height:80px; overflow-y:auto;">
                    Click refresh to load history
                </div>
            </div>
        </div>

        <!-- Sixth Row: Windows, TTS, QR -->
        <div class="controls" style="margin-top: 15px;">
            <!-- Window Manager Panel -->
            <div class="control-panel">
                <h3>ü™ü Windows</h3>
                <button class="dark" onclick="refreshWindowList()" style="width:100%; margin-bottom:5px;">üîÑ
                    Refresh</button>
                <div id="windowList" style="font-size:11px; max-height:80px; overflow-y:auto;">
                    Click refresh to load windows
                </div>
            </div>

            <!-- TTS Panel -->
            <div class="control-panel">
                <h3>üîä Text-to-Speech</h3>
                <input type="text" id="ttsText" placeholder="Enter text to speak..."
                    style="width:100%; margin-bottom:5px;">
                <div class="button-row">
                    <button class="secondary" onclick="speakText()">üîä Speak</button>
                    <button class="dark" onclick="stopSpeaking()">‚èπÔ∏è Stop</button>
                </div>
            </div>

            <!-- QR Code Panel -->
            <div class="control-panel" style="text-align:center;">
                <h3>üì± Connect Mobile</h3>
                <img id="qrCode" src="/qr" alt="QR Code"
                    style="width:100px; height:100px; margin:5px auto; border-radius:8px;">
                <div style="font-size:11px; color:#888;">Scan to connect</div>
            </div>
        </div>
    </div>

    <script>
        let pc = null;
        let dataChannel = null;
        let reconnectAttempts = 0;
        let maxReconnectAttempts = 5;
        let reconnectTimeout = null;
        let statsInterval = null;
        let lastBytesReceived = 0;
        let lastTimestamp = 0;

        // Active modifiers state
        const modifiers = {
            shift: false,
            ctrl: false,
            alt: false,
            win: false
        };

        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const connectionLog = document.getElementById('connectionLog');
        const remoteVideo = document.getElementById('remoteVideo');

        const ICE_SERVERS = [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
        ];

        function log(msg) {
            const time = new Date().toLocaleTimeString();
            connectionLog.innerHTML += `[${time}] ${msg}\n`;
            connectionLog.scrollTop = connectionLog.scrollHeight;
            console.log(msg);
        }

        function setStatus(status) {
            statusDot.className = 'status-dot';
            if (status === 'connected') {
                statusDot.classList.add('connected');
                statusText.textContent = 'Connected';
                document.getElementById('connectBtn').disabled = true;
                document.getElementById('disconnectBtn').disabled = false;
                startStatsMonitoring();
            } else if (status === 'connecting') {
                statusDot.classList.add('connecting');
                statusText.textContent = 'Connecting...';
            } else {
                statusText.textContent = 'Disconnected';
                document.getElementById('connectBtn').disabled = false;
                document.getElementById('disconnectBtn').disabled = true;
                stopStatsMonitoring();
            }
        }

        function startStatsMonitoring() {
            statsInterval = setInterval(async () => {
                if (pc) {
                    try {
                        const stats = await pc.getStats();
                        stats.forEach(report => {
                            if (report.type === 'inbound-rtp' && report.kind === 'video') {
                                // Calculate FPS
                                const fps = report.framesPerSecond || '--';
                                document.getElementById('fpsValue').textContent = Math.round(fps);

                                // Calculate bitrate
                                const now = performance.now();
                                const bytes = report.bytesReceived || 0;
                                if (lastTimestamp > 0) {
                                    const bitrate = ((bytes - lastBytesReceived) * 8) / ((now - lastTimestamp) / 1000);
                                    document.getElementById('bitrateValue').textContent =
                                        bitrate > 1000000 ? `${(bitrate / 1000000).toFixed(1)}Mbps` :
                                            `${(bitrate / 1000).toFixed(0)}kbps`;
                                }
                                lastBytesReceived = bytes;
                                lastTimestamp = now;

                                // Resolution
                                if (report.frameWidth && report.frameHeight) {
                                    document.getElementById('qualityOverlay').textContent =
                                        `${report.frameWidth}x${report.frameHeight} @ ${Math.round(fps)}fps`;
                                }
                            }
                            if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                                const latency = report.currentRoundTripTime;
                                if (latency) {
                                    document.getElementById('latencyValue').textContent = `${Math.round(latency * 1000)}ms`;
                                    updateSignalStrength(latency);
                                }
                            }
                        });
                    } catch (e) { }
                }
            }, 1000);
        }



        function updateSignalStrength(latency) {
            const el = document.getElementById('signalStrength');
            if (!latency) {
                el.style.opacity = '0.3';
                el.style.color = '#888';
                return;
            }

            // Latency thresholds: <50ms (Excellent), <100ms (Good), <200ms (Fair), >200ms (Poor)
            el.style.opacity = '1';
            if (latency < 0.05) {
                el.style.color = '#4ade80'; // Green
            } else if (latency < 0.1) {
                el.style.color = '#a3e635'; // Lime
            } else if (latency < 0.2) {
                el.style.color = '#facc15'; // Yellow
            } else {
                el.style.color = '#ef4444'; // Red
            }
        }

        function stopStatsMonitoring() {
            if (statsInterval) {
                clearInterval(statsInterval);
                statsInterval = null;
            }
            document.getElementById('fpsValue').textContent = '--';
            document.getElementById('latencyValue').textContent = '--';
            document.getElementById('bitrateValue').textContent = '--';
            document.getElementById('qualityOverlay').textContent = '--';
            updateSignalStrength(null);
        }

        async function connect() {
            try {
                setStatus('connecting');
                log('Initiating WebRTC connection...');

                pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });

                pc.ontrack = (event) => {
                    log('Received video track');
                    remoteVideo.srcObject = event.streams[0];
                };

                pc.ondatachannel = (event) => {
                    dataChannel = event.channel;
                    log('Data channel: ' + dataChannel.label);

                    dataChannel.onopen = () => {
                        log('Data channel opened');
                        setStatus('connected');
                        reconnectAttempts = 0;
                    };

                    dataChannel.onclose = () => {
                        log('Data channel closed');
                        handleDisconnect();
                    };

                    dataChannel.onmessage = (e) => {
                        log('‚Üê ' + e.data);
                    };
                };

                pc.oniceconnectionstatechange = () => {
                    log('ICE: ' + pc.iceConnectionState);
                    if (pc.iceConnectionState === 'connected') {
                        setStatus('connected');
                    } else if (pc.iceConnectionState === 'failed' || pc.iceConnectionState === 'disconnected') {
                        handleDisconnect();
                    }
                };

                log('Requesting offer...');
                const offerResponse = await fetch('/webrtc/offer', { method: 'POST' });
                const offerData = await offerResponse.json();

                if (offerData.error) {
                    throw new Error(offerData.error);
                }

                log('Setting remote description...');
                await pc.setRemoteDescription(new RTCSessionDescription(offerData.offer));

                log('Creating answer...');
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);

                await waitForIceGathering();

                log('Sending answer...');
                const answerResponse = await fetch('/webrtc/answer', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        pc_id: offerData.pc_id,
                        answer: {
                            sdp: pc.localDescription.sdp,
                            type: pc.localDescription.type
                        }
                    })
                });

                const result = await answerResponse.json();
                if (result.status === 'connected') {
                    log('‚úì Connection established!');
                } else {
                    throw new Error(result.error || 'Unknown error');
                }

            } catch (error) {
                log('‚úó Error: ' + error.message);
                handleDisconnect();
            }
        }

        function handleDisconnect() {
            setStatus('disconnected');

            if (document.getElementById('autoReconnect').checked && reconnectAttempts < maxReconnectAttempts) {
                reconnectAttempts++;
                const delay = Math.min(1000 * Math.pow(2, reconnectAttempts - 1), 10000);
                log(`Reconnecting in ${delay / 1000}s (${reconnectAttempts}/${maxReconnectAttempts})...`);
                reconnectTimeout = setTimeout(connect, delay);
            }
        }

        function waitForIceGathering() {
            return new Promise((resolve) => {
                if (pc.iceGatheringState === 'complete') {
                    resolve();
                    return;
                }

                const checkState = () => {
                    if (pc.iceGatheringState === 'complete') {
                        pc.removeEventListener('icegatheringstatechange', checkState);
                        resolve();
                    }
                };

                pc.addEventListener('icegatheringstatechange', checkState);
                setTimeout(resolve, 3000);
            });
        }

        function disconnect() {
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
                reconnectTimeout = null;
            }
            reconnectAttempts = maxReconnectAttempts; // Prevent auto-reconnect

            if (dataChannel) dataChannel.close();
            if (pc) pc.close();
            pc = null;
            dataChannel = null;
            remoteVideo.srcObject = null;
            setStatus('disconnected');
            log('Disconnected');

            reconnectAttempts = 0; // Reset for next manual connect
        }

        function sendCommand(cmd) {
            if (dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(JSON.stringify(cmd));
                // Don't log mouse moves to avoid clutter
                if (cmd.type !== 'mouse_move') {
                    log('‚Üí ' + JSON.stringify(cmd).substring(0, 60));
                }
            } else {
                if (cmd.type !== 'mouse_move') {
                    log('‚úó Not connected');
                }
            }
        }

        function updateQuality() {
            const fps = parseInt(document.getElementById('fpsSelect').value);
            const res = parseInt(document.getElementById('resSelect').value);
            const maxWidth = res === 0 ? 3840 : res === 720 ? 1280 : 1920; // 0 = native (max 4k), 720p=1280, 1080p=1920

            log(`Updating quality: ${fps} FPS, Max Width: ${maxWidth}`);

            sendCommand({
                type: 'config',
                data: {
                    fps: fps,
                    max_width: maxWidth
                }
            });
        }

        function sendAICommand() {
            const input = document.getElementById('aiCommand');
            const prompt = input.value.trim();
            if (prompt) {
                sendCommand({ prompt: prompt });
                input.value = '';
            }
        }

        function sendKey(key) {
            // Check for modifiers
            const activeModifiers = Object.keys(modifiers).filter(k => modifiers[k]);

            if (activeModifiers.length > 0) {
                // Send as hotkey
                sendHotkey([...activeModifiers, key]);

                // Clear modifiers after use
                clearModifiers();
            } else {
                sendCommand({ type: 'key_press', data: { key: key } });
            }
        }

        function sendHotkey(keys) {
            sendCommand({ type: 'hotkey', data: { keys: keys } });
        }

        function toggleModifier(key) {
            modifiers[key] = !modifiers[key];
            const btn = document.getElementById('btn' + key.charAt(0).toUpperCase() + key.slice(1));
            if (modifiers[key]) {
                btn.classList.add('modifier-active');
            } else {
                btn.classList.remove('modifier-active');
            }
        }

        function clearModifiers() {
            for (const key in modifiers) {
                modifiers[key] = false;
                const btn = document.getElementById('btn' + key.charAt(0).toUpperCase() + key.slice(1));
                if (btn) btn.classList.remove('modifier-active');
            }
        }

        // Fullscreen toggle
        function toggleFullscreen() {
            const container = document.querySelector('.video-container');
            if (!document.fullscreenElement) {
                container.requestFullscreen().catch(err => {
                    log('Fullscreen error: ' + err.message);
                });
            } else {
                document.exitFullscreen();
            }
        }

        // Wheel scroll support
        remoteVideo.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (!dataChannel || dataChannel.readyState !== 'open') return;

            // Scroll amount based on wheel delta
            const amount = e.deltaY > 0 ? -120 : 120;
            sendCommand({ type: 'scroll', data: { amount } });
        }, { passive: false });

        // Drag support variables
        let isDragging = false;
        let dragStartTime = 0;

        remoteVideo.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return; // Only left button
            if (!dataChannel || dataChannel.readyState !== 'open') return;

            isDragging = true;
            dragStartTime = Date.now();

            const rect = remoteVideo.getBoundingClientRect();
            const nx = (e.clientX - rect.left) / rect.width;
            const ny = (e.clientY - rect.top) / rect.height;

            sendCommand({ type: 'mouse_move', data: { nx, ny } });
            sendCommand({ type: 'mouse_down', data: { button: 'left' } });
        });

        remoteVideo.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            if (!dataChannel || dataChannel.readyState !== 'open') return;

            const rect = remoteVideo.getBoundingClientRect();
            const nx = (e.clientX - rect.left) / rect.width;
            const ny = (e.clientY - rect.top) / rect.height;

            sendCommand({ type: 'mouse_move', data: { nx, ny } });
        });

        document.addEventListener('mouseup', (e) => {
            if (!isDragging) return;

            isDragging = false;

            if (!dataChannel || dataChannel.readyState !== 'open') return;

            sendCommand({ type: 'mouse_up', data: { button: 'left' } });
        });

        // Prevent default click since we handle mousedown/up for dragging
        remoteVideo.addEventListener('click', (e) => {
            e.preventDefault();
            // Click is now handled by mousedown + mouseup sequence
        });

        // Right-click context menu
        remoteVideo.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if (!dataChannel || dataChannel.readyState !== 'open') return;

            const rect = remoteVideo.getBoundingClientRect();
            const nx = (e.clientX - rect.left) / rect.width;
            const ny = (e.clientY - rect.top) / rect.height;

            sendCommand({ type: 'mouse_move', data: { nx, ny } });
            setTimeout(() => {
                sendCommand({ type: 'mouse_click', data: { button: 'right' } });
            }, 50);
        });

        // Touch support for mobile browsers
        let touchStartPos = null;

        remoteVideo.addEventListener('touchstart', (e) => {
            if (!dataChannel || dataChannel.readyState !== 'open') return;
            if (e.touches.length === 1) {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = remoteVideo.getBoundingClientRect();
                const nx = (touch.clientX - rect.left) / rect.width;
                const ny = (touch.clientY - rect.top) / rect.height;

                touchStartPos = { nx, ny, time: Date.now() };
                sendCommand({ type: 'mouse_move', data: { nx, ny } });
            }
        }, { passive: false });

        remoteVideo.addEventListener('touchend', (e) => {
            if (!dataChannel || dataChannel.readyState !== 'open') return;
            if (touchStartPos && (Date.now() - touchStartPos.time) < 300) {
                // Quick tap = click
                sendCommand({ type: 'mouse_click', data: { button: 'left' } });
            }
            touchStartPos = null;
        });

        remoteVideo.addEventListener('touchmove', (e) => {
            if (!dataChannel || dataChannel.readyState !== 'open') return;
            if (e.touches.length === 2) {
                // Two-finger scroll
                e.preventDefault();
                // Calculate scroll direction
                sendCommand({ type: 'scroll', data: { amount: 100 } });
            }
        }, { passive: false });

        // ============ NEW FEATURE FUNCTIONS ============

        // Audio state
        let audioMuted = false;

        // Load monitors on connect
        async function loadMonitors() {
            try {
                const res = await fetch('/monitors/list');
                const data = await res.json();
                const select = document.getElementById('monitorSelect');
                select.innerHTML = '';
                data.monitors.forEach(m => {
                    const opt = document.createElement('option');
                    opt.value = m.index;
                    opt.textContent = `${m.name} (${m.width}x${m.height})`;
                    if (m.selected) opt.selected = true;
                    select.appendChild(opt);
                });
            } catch (e) {
                console.error('Failed to load monitors:', e);
            }
        }

        async function selectMonitor() {
            const idx = parseInt(document.getElementById('monitorSelect').value);
            try {
                await fetch('/monitors/select', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ index: idx })
                });
                log(`Switched to monitor ${idx}`);
            } catch (e) {
                log('Failed to switch monitor');
            }
        }

        function toggleAudio() {
            audioMuted = !audioMuted;
            const btn = document.getElementById('audioToggle');
            btn.textContent = audioMuted ? 'üîá Off' : 'üîä On';

            fetch('/settings/audio', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ muted: audioMuted })
            });
        }

        function setVolume() {
            const vol = parseInt(document.getElementById('volumeSlider').value) / 100;
            fetch('/settings/audio', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ volume: vol })
            });
        }

        // Clipboard functions
        async function syncClipboardFrom() {
            try {
                const res = await fetch('/clipboard');
                const data = await res.json();
                if (data.content_type === 'text' && data.data) {
                    await navigator.clipboard.writeText(data.data);
                    log('Clipboard synced from PC');
                } else {
                    log('No text in PC clipboard');
                }
            } catch (e) {
                log('Clipboard sync failed: ' + e.message);
            }
        }

        async function syncClipboardTo() {
            try {
                const text = await navigator.clipboard.readText();
                await fetch('/clipboard', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ content_type: 'text', data: text })
                });
                log('Clipboard sent to PC');
            } catch (e) {
                log('Clipboard send failed: ' + e.message);
            }
        }

        // File functions
        async function browseFiles() {
            const path = document.getElementById('filePath').value || null;
            try {
                const res = await fetch('/files/list' + (path ? `?path=${encodeURIComponent(path)}` : ''));
                const data = await res.json();
                const list = document.getElementById('fileList');
                if (data.items) {
                    list.innerHTML = data.items.slice(0, 10).map(f =>
                        `<div onclick="selectFile('${f.path.replace(/\\/g, '\\\\')}')" style="cursor:pointer;padding:2px;${f.is_dir ? 'color:#4ade80;' : ''}">${f.is_dir ? 'üìÅ' : 'üìÑ'} ${f.name}</div>`
                    ).join('');
                    if (data.path) document.getElementById('filePath').value = data.path;
                }
            } catch (e) {
                log('Browse failed: ' + e.message);
            }
        }

        function selectFile(path) {
            document.getElementById('filePath').value = path;
        }

        function downloadFile() {
            const path = document.getElementById('filePath').value;
            if (path) {
                window.open('/files/download?path=' + encodeURIComponent(path), '_blank');
            }
        }

        // Recording functions
        let isRecording = false;

        async function toggleRecording() {
            const btn = document.getElementById('recordBtn');
            const status = document.getElementById('recordingStatus');

            if (!isRecording) {
                try {
                    const res = await fetch('/recording/start', { method: 'POST' });
                    const data = await res.json();
                    if (data.status === 'ok') {
                        isRecording = true;
                        btn.textContent = '‚èπÔ∏è Stop';
                        btn.classList.remove('secondary');
                        btn.classList.add('disconnect');
                        status.textContent = `Recording: ${data.filename}`;
                    } else {
                        status.textContent = data.message || 'Failed to start';
                    }
                } catch (e) {
                    status.textContent = 'Error: ' + e.message;
                }
            } else {
                try {
                    const res = await fetch('/recording/stop', { method: 'POST' });
                    const data = await res.json();
                    isRecording = false;
                    btn.textContent = '‚è∫Ô∏è Start';
                    btn.classList.add('secondary');
                    btn.classList.remove('disconnect');
                    status.textContent = `Saved: ${data.filename || 'recording'} (${(data.duration || 0).toFixed(1)}s)`;
                } catch (e) {
                    status.textContent = 'Stop error: ' + e.message;
                }
            }
        }

        async function pauseRecording() {
            try {
                await fetch('/recording/pause', { method: 'POST' });
                document.getElementById('recordingStatus').textContent = 'Paused';
            } catch (e) { }
        }

        async function listRecordings() {
            try {
                const res = await fetch('/recording/list');
                const data = await res.json();
                const list = document.getElementById('fileList');
                if (data.recordings) {
                    list.innerHTML = data.recordings.slice(0, 5).map(r =>
                        `<div onclick="window.open('/recording/download?filename=${r.filename}','_blank')" style="cursor:pointer;padding:2px;">üé¨ ${r.filename}</div>`
                    ).join('');
                }
            } catch (e) { }
        }

        // Wake-on-LAN
        async function sendWakeOnLan() {
            const mac = document.getElementById('wolMac').value;
            if (!mac) {
                log('Enter MAC address first');
                return;
            }
            try {
                const res = await fetch('/wol/wake', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mac_address: mac })
                });
                const data = await res.json();
                log(data.message || 'WoL packet sent');
            } catch (e) {
                log('WoL failed: ' + e.message);
            }
        }

        // Load WoL info on page load
        async function loadWolInfo() {
            try {
                const res = await fetch('/wol/info');
                const data = await res.json();
                if (data.this_pc_mac) {
                    document.getElementById('wolMac').placeholder = data.this_pc_mac;
                }
            } catch (e) { }
        }

        // Initialize on page load
        window.addEventListener('load', () => {
            loadWolInfo();
        });

        // Auto-load monitors on connection
        const origConnect = connect;
        connect = async function () {
            await origConnect();
            setTimeout(loadMonitors, 1000);
            startLatencyTracking();
        };

        // ============ V3.1 NEW FEATURES ============

        // Screenshot capture
        function takeScreenshot() {
            const video = document.getElementById('remoteVideo');
            if (!video.videoWidth) {
                log('No video to capture');
                return;
            }

            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0);

            // Download the screenshot
            const link = document.createElement('a');
            link.download = `spacelink_screenshot_${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();

            log('Screenshot saved');
        }

        // Picture-in-Picture
        async function togglePiP() {
            const video = document.getElementById('remoteVideo');
            try {
                if (document.pictureInPictureElement) {
                    await document.exitPictureInPicture();
                    log('Exited PiP');
                } else if (video.videoWidth) {
                    await video.requestPictureInPicture();
                    log('Entered PiP');
                }
            } catch (e) {
                log('PiP not supported: ' + e.message);
            }
        }

        // Latency tracking
        let latencyInterval = null;
        function startLatencyTracking() {
            if (latencyInterval) clearInterval(latencyInterval);

            const badge = document.getElementById('latencyBadge');
            badge.style.display = 'block';

            latencyInterval = setInterval(async () => {
                if (!pc || pc.connectionState !== 'connected') return;

                try {
                    const stats = await pc.getStats();
                    stats.forEach(report => {
                        if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                            const rtt = report.currentRoundTripTime;
                            if (rtt !== undefined) {
                                const ms = Math.round(rtt * 1000);
                                document.getElementById('pingValue').textContent = ms;
                                document.getElementById('latencyValue').textContent = ms + 'ms';

                                // Update signal strength based on latency
                                const signal = document.getElementById('signalStrength');
                                if (ms < 50) signal.style.opacity = '1';
                                else if (ms < 100) signal.style.opacity = '0.75';
                                else if (ms < 200) signal.style.opacity = '0.5';
                                else signal.style.opacity = '0.25';
                            }
                        }
                    });
                } catch (e) { }
            }, 1000);
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Only when connected and not typing in input
            if (!dataChannel || dataChannel.readyState !== 'open') return;
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            // F11 - Fullscreen
            if (e.key === 'F11') {
                e.preventDefault();
                toggleFullscreen();
            }
            // Ctrl+P - PiP
            if (e.ctrlKey && e.key === 'p') {
                e.preventDefault();
                togglePiP();
            }
            // Ctrl+S - Screenshot
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                takeScreenshot();
            }
        });

        // ============ GAMEPAD SUPPORT ============

        let gamepadInterval = null;
        let lastGamepadState = {};

        function startGamepadPolling() {
            if (gamepadInterval) return;

            gamepadInterval = setInterval(() => {
                if (!dataChannel || dataChannel.readyState !== 'open') return;

                const gamepads = navigator.getGamepads();
                for (const gp of gamepads) {
                    if (!gp) continue;

                    // D-pad / Left stick for mouse movement
                    const x = gp.axes[0];
                    const y = gp.axes[1];
                    if (Math.abs(x) > 0.2 || Math.abs(y) > 0.2) {
                        sendCommand({
                            type: 'mouse_move_relative',
                            data: { dx: Math.round(x * 10), dy: Math.round(y * 10) }
                        });
                    }

                    // A button = left click
                    if (gp.buttons[0].pressed && !lastGamepadState[0]) {
                        sendCommand({ type: 'mouse_click', data: { button: 'left' } });
                    }
                    // B button = right click
                    if (gp.buttons[1].pressed && !lastGamepadState[1]) {
                        sendCommand({ type: 'mouse_click', data: { button: 'right' } });
                    }
                    // X button = Enter
                    if (gp.buttons[2].pressed && !lastGamepadState[2]) {
                        sendCommand({ type: 'key_press', data: { key: 'enter' } });
                    }
                    // Y button = Escape
                    if (gp.buttons[3].pressed && !lastGamepadState[3]) {
                        sendCommand({ type: 'key_press', data: { key: 'esc' } });
                    }
                    // Bumpers = scroll
                    if (gp.buttons[4].pressed) {
                        sendCommand({ type: 'scroll', data: { amount: 100 } });
                    }
                    if (gp.buttons[5].pressed) {
                        sendCommand({ type: 'scroll', data: { amount: -100 } });
                    }

                    // Store state
                    lastGamepadState = {};
                    gp.buttons.forEach((b, i) => lastGamepadState[i] = b.pressed);
                }
            }, 50);

            log('Gamepad support enabled');
        }

        // Start gamepad on connection
        window.addEventListener('gamepadconnected', (e) => {
            log(`Gamepad connected: ${e.gamepad.id}`);
            startGamepadPolling();
        });

        // ============ IMPROVED TOUCH GESTURES ============

        let touchState = {
            startX: 0, startY: 0,
            startDist: 0,
            lastTap: 0
        };

        const video = document.getElementById('remoteVideo');

        video.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                touchState.startX = e.touches[0].clientX;
                touchState.startY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                // Pinch start
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                touchState.startDist = Math.sqrt(dx * dx + dy * dy);
            }
        });

        video.addEventListener('touchend', (e) => {
            if (e.changedTouches.length === 1) {
                const dx = e.changedTouches[0].clientX - touchState.startX;
                const dy = e.changedTouches[0].clientY - touchState.startY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Detect double tap
                const now = Date.now();
                if (dist < 10 && now - touchState.lastTap < 300) {
                    sendCommand({ type: 'double_click', data: { button: 'left' } });
                    log('Double tap');
                }
                touchState.lastTap = now;

                // Swipe detection
                if (dist > 50) {
                    if (Math.abs(dx) > Math.abs(dy)) {
                        // Horizontal swipe
                        if (dx > 0) {
                            sendCommand({ type: 'key_press', data: { key: 'right' } });
                        } else {
                            sendCommand({ type: 'key_press', data: { key: 'left' } });
                        }
                    } else {
                        // Vertical swipe = scroll
                        sendCommand({ type: 'scroll', data: { amount: dy > 0 ? -200 : 200 } });
                    }
                }
            }
        });

        video.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2) {
                e.preventDefault();
                // Pinch zoom
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (touchState.startDist > 0) {
                    const scale = dist / touchState.startDist;
                    if (scale > 1.2) {
                        // Zoom in = Ctrl++
                        sendCommand({ type: 'hotkey', data: { keys: ['ctrl', 'plus'] } });
                        touchState.startDist = dist;
                    } else if (scale < 0.8) {
                        // Zoom out = Ctrl+-
                        sendCommand({ type: 'hotkey', data: { keys: ['ctrl', 'minus'] } });
                        touchState.startDist = dist;
                    }
                }
            }
        }, { passive: false });

        // ============ ADAPTIVE BITRATE ============

        let qualityHistory = [];

        function checkAdaptiveBitrate() {
            const latency = parseInt(document.getElementById('pingValue').textContent) || 0;
            qualityHistory.push(latency);
            if (qualityHistory.length > 10) qualityHistory.shift();

            const avgLatency = qualityHistory.reduce((a, b) => a + b, 0) / qualityHistory.length;
            const currentRes = document.getElementById('resSelect').value;

            // Auto-adjust quality based on latency
            if (avgLatency > 200 && currentRes !== '720') {
                document.getElementById('resSelect').value = '720';
                updateQuality();
                log('Auto-lowered quality (high latency)');
            } else if (avgLatency < 50 && currentRes === '720') {
                document.getElementById('resSelect').value = '1080';
                updateQuality();
                log('Auto-raised quality (low latency)');
            }
        }

        // Check adaptive bitrate every 5 seconds when connected
        setInterval(() => {
            if (pc && pc.connectionState === 'connected') {
                checkAdaptiveBitrate();
            }
        }, 5000);

        // ============ V3.2 FEATURES ============

        // Theme toggle
        let darkMode = true;
        function toggleTheme() {
            darkMode = !darkMode;
            document.body.style.background = darkMode
                ? 'linear-gradient(135deg, #1a1a2e 0%, #16213e 100%)'
                : 'linear-gradient(135deg, #f0f0f0 0%, #e0e0e0 100%)';
            document.body.style.color = darkMode ? '#fff' : '#333';

            document.querySelectorAll('.control-panel').forEach(p => {
                p.style.background = darkMode ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.08)';
            });

            log(darkMode ? 'Dark mode' : 'Light mode');
        }

        // Help modal
        function toggleHelp() {
            const modal = document.getElementById('helpModal');
            const isVisible = modal.style.display === 'flex';
            modal.style.display = isVisible ? 'none' : 'flex';
        }

        // Close help on Escape
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                document.getElementById('helpModal').style.display = 'none';
            }
        });

        // Drag & drop file upload
        const container = document.querySelector('.container');

        container.addEventListener('dragover', (e) => {
            e.preventDefault();
            container.style.outline = '3px dashed #4ade80';
        });

        container.addEventListener('dragleave', (e) => {
            container.style.outline = 'none';
        });

        container.addEventListener('drop', async (e) => {
            e.preventDefault();
            container.style.outline = 'none';

            const files = e.dataTransfer.files;
            if (files.length === 0) return;

            for (const file of files) {
                const formData = new FormData();
                formData.append('file', file);

                try {
                    log(`Uploading: ${file.name}`);
                    const res = await fetch('/files/upload', {
                        method: 'POST',
                        body: formData
                    });
                    const data = await res.json();
                    log(`Uploaded: ${data.filename || file.name}`);
                    playSound('success');
                } catch (err) {
                    log(`Upload failed: ${file.name}`);
                    playSound('error');
                }
            }
        });

        // Sound notifications
        function playSound(type) {
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();

            osc.connect(gain);
            gain.connect(ctx.destination);

            if (type === 'success') {
                osc.frequency.value = 800;
                gain.gain.value = 0.1;
            } else if (type === 'error') {
                osc.frequency.value = 200;
                gain.gain.value = 0.1;
            } else {
                osc.frequency.value = 440;
                gain.gain.value = 0.05;
            }

            osc.start();
            osc.stop(ctx.currentTime + 0.1);
        }

        // Bandwidth tracking
        setInterval(async () => {
            if (!pc || pc.connectionState !== 'connected') return;

            try {
                const stats = await pc.getStats();
                let bytesReceived = 0;

                stats.forEach(report => {
                    if (report.type === 'inbound-rtp' && report.mediaType === 'video') {
                        bytesReceived = report.bytesReceived;
                    }
                });

                // Calculate bandwidth in Mbps
                const mbps = ((bytesReceived * 8) / 1000000).toFixed(2);
                document.getElementById('bitrateValue').textContent = mbps + ' Mbps';
            } catch (e) { }
        }, 2000);

        // ============ V3.3 FEATURES ============

        // Power control
        async function powerAction(action) {
            try {
                const res = await fetch(`/power/${action}`, { method: 'POST' });
                const data = await res.json();
                log(data.message || `Power: ${action}`);
                playSound('success');
            } catch (e) {
                log(`Power action failed: ${e.message}`);
            }
        }

        function confirmPower(action) {
            if (confirm(`Are you sure you want to ${action} the PC?`)) {
                powerAction(action);
            }
        }

        // Quick app launcher
        function launchApp(app) {
            sendCommand({ prompt: `open ${app}` });
            log(`Launching: ${app}`);
            playSound('success');
        }

        // Favorites with localStorage
        let favorites = JSON.parse(localStorage.getItem('spacelink_favorites') || '[]');

        function renderFavorites() {
            const list = document.getElementById('favoritesList');
            list.innerHTML = favorites.map((f, i) =>
                `<button class="dark" onclick="executeFavorite(${i})" title="${f.command}" style="position:relative;">
                    ${f.icon} ${f.name}
                    <span onclick="removeFavorite(event, ${i})" style="position:absolute;top:-5px;right:-5px;background:#f00;border-radius:50%;width:15px;height:15px;font-size:10px;line-height:15px;">√ó</span>
                </button>`
            ).join('') + '<button class="secondary" onclick="addFavorite()">+ Add</button>';
        }

        function addFavorite() {
            const name = prompt('Favorite name (e.g., "VS Code"):', 'My App');
            if (!name) return;
            const command = prompt('Command (e.g., "open code" or "type hello"):', 'open notepad');
            if (!command) return;
            const icon = prompt('Icon emoji:', '‚≠ê');

            favorites.push({ name, command, icon: icon || '‚≠ê' });
            localStorage.setItem('spacelink_favorites', JSON.stringify(favorites));
            renderFavorites();
            log(`Added favorite: ${name}`);
        }

        function executeFavorite(index) {
            const fav = favorites[index];
            if (fav) {
                sendCommand({ prompt: fav.command });
                log(`Executed: ${fav.name}`);
                playSound('success');
            }
        }

        function removeFavorite(e, index) {
            e.stopPropagation();
            favorites.splice(index, 1);
            localStorage.setItem('spacelink_favorites', JSON.stringify(favorites));
            renderFavorites();
        }

        // Initialize favorites on load
        window.addEventListener('load', renderFavorites);

        // ============ V3.4 FEATURES ============

        // System stats
        async function refreshStats() {
            try {
                const res = await fetch('/stats');
                const data = await res.json();

                document.getElementById('cpuValue').textContent = data.cpu.percent + '%';
                document.getElementById('ramValue').textContent = data.memory.percent + '%';
                document.getElementById('diskValue').textContent = data.disk.percent + '%';

                // Battery
                const battery = await fetch('/stats/battery').then(r => r.json());
                document.getElementById('batteryValue').textContent = battery.percent + '%' + (battery.plugged ? '‚ö°' : '');

                // Processes
                const processList = document.getElementById('processList');
                processList.innerHTML = data.top_processes.map(p =>
                    `<div style="display:flex; justify-content:space-between; padding:2px 0; border-bottom:1px solid rgba(255,255,255,0.1);">
                        <span>${p.name}</span>
                        <span style="color:#4ade80;">${p.cpu}%</span>
                    </div>`
                ).join('');

            } catch (e) {
                console.error('Stats error:', e);
            }
        }

        // Auto-refresh stats every 3 seconds
        setInterval(refreshStats, 3000);
        window.addEventListener('load', refreshStats);

        // ============ V3.5 FEATURES ============

        // Macro recording
        let macroRecording = false;

        async function toggleMacroRecording() {
            const btn = document.getElementById('macroRecordBtn');
            const status = document.getElementById('macroStatus');

            if (!macroRecording) {
                // Start recording
                const name = prompt('Macro name:', 'my_macro');
                if (!name) return;

                const res = await fetch('/macro/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name })
                });
                const data = await res.json();

                if (data.status === 'ok') {
                    macroRecording = true;
                    btn.textContent = '‚èπÔ∏è Stop';
                    btn.classList.remove('secondary');
                    btn.classList.add('disconnect');
                    status.textContent = data.message;
                    status.style.color = '#ef4444';
                    log('Started recording: ' + name);
                }
            } else {
                // Stop recording
                const res = await fetch('/macro/stop', { method: 'POST' });
                const data = await res.json();

                macroRecording = false;
                btn.textContent = '‚è∫Ô∏è Record';
                btn.classList.remove('disconnect');
                btn.classList.add('secondary');
                status.textContent = data.message;
                status.style.color = '#4ade80';
                log(data.message);
                playSound('success');
                listMacros();
            }
        }

        async function listMacros() {
            try {
                const res = await fetch('/macro/list');
                const macros = await res.json();

                const list = document.getElementById('macroList');
                list.innerHTML = macros.map(m =>
                    `<div style="display:flex; justify-content:space-between; padding:2px 0;">
                        <span>üé¨ ${m.name}</span>
                        <span style="color:#888;">${m.command_count} cmds</span>
                    </div>`
                ).join('') || 'No macros saved';
            } catch (e) {
                console.error('List macros error:', e);
            }
        }

        // Clipboard history
        async function refreshClipboardHistory() {
            try {
                // First add current to history
                await fetch('/clipboard/history/add', { method: 'POST' });

                // Then get history
                const res = await fetch('/clipboard/history');
                const data = await res.json();

                const list = document.getElementById('clipboardHistory');
                list.innerHTML = data.history.map((item, i) =>
                    `<div style="padding:3px 0; border-bottom:1px solid rgba(255,255,255,0.1); cursor:pointer;" 
                         onclick="pasteFromHistory(${i})" title="${item.data}">
                        ${item.type === 'text' ? 'üìù' : 'üñºÔ∏è'} ${item.data.substring(0, 30)}...
                    </div>`
                ).join('') || 'No clipboard history';
            } catch (e) {
                console.error('Clipboard history error:', e);
            }
        }

        function pasteFromHistory(index) {
            log(`Selected clipboard item ${index + 1}`);
            // Could implement paste functionality here
        }

        // Load macros on startup
        window.addEventListener('load', listMacros);

        // ============ V3.6 FEATURES ============

        // Window Manager
        async function refreshWindowList() {
            try {
                const res = await fetch('/windows');
                const windows = await res.json();

                const list = document.getElementById('windowList');
                list.innerHTML = windows.map(w =>
                    `<div style="display:flex; justify-content:space-between; align-items:center; padding:3px 0; border-bottom:1px solid rgba(255,255,255,0.1);">
                        <span style="flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;" title="${w.title}">${w.title}</span>
                        <div style="display:flex; gap:2px;">
                            <button onclick="windowAction(${w.hwnd}, 'focus')" style="padding:2px 4px; font-size:10px;">üëÅÔ∏è</button>
                            <button onclick="windowAction(${w.hwnd}, 'minimize')" style="padding:2px 4px; font-size:10px;">‚ûñ</button>
                            <button onclick="windowAction(${w.hwnd}, 'maximize')" style="padding:2px 4px; font-size:10px;">‚¨ú</button>
                            <button onclick="windowAction(${w.hwnd}, 'close')" style="padding:2px 4px; font-size:10px;">‚úï</button>
                        </div>
                    </div>`
                ).join('') || 'No windows found';
            } catch (e) {
                console.error('Window list error:', e);
            }
        }

        async function windowAction(hwnd, action) {
            try {
                await fetch(`/windows/${hwnd}/${action}`, { method: 'POST' });
                log(`Window ${action}`);
                refreshWindowList();
            } catch (e) {
                log(`Window action failed: ${e.message}`);
            }
        }

        // Text-to-Speech
        async function speakText() {
            const text = document.getElementById('ttsText').value;
            if (!text) return;

            try {
                const res = await fetch('/tts/speak', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text })
                });
                const data = await res.json();
                log(data.message);
            } catch (e) {
                log(`TTS error: ${e.message}`);
            }
        }

        async function stopSpeaking() {
            try {
                await fetch('/tts/stop', { method: 'POST' });
                log('Speech stopped');
            } catch (e) {
                log(`Stop TTS error: ${e.message}`);
            }
        }

        // High contrast mode
        let highContrast = false;
        function toggleHighContrast() {
            highContrast = !highContrast;
            if (highContrast) {
                document.body.style.background = '#000';
                document.body.style.color = '#fff';
                document.querySelectorAll('.control-panel').forEach(p => {
                    p.style.background = '#111';
                    p.style.border = '2px solid #fff';
                });
            } else {
                toggleTheme(); toggleTheme(); // Reset to current theme
            }
            log(highContrast ? 'High contrast ON' : 'High contrast OFF');
        }
    </script>
</body>

</html>